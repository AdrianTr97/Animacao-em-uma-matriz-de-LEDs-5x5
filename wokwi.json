{
    "version": 1,
    "author": "Eduardo Lino",
    "title": "teste00008",
    "description": "Um exemplo de projeto para controlar uma matriz de LEDs 5x5 com um teclado matricial.",
    "files": {
      "main.c": {
        "content": "#include \"pico/stdlib.h\"\n#include <stdio.h>\n#include \"ws2812.pio.h\"  // Biblioteca para WS2812\n#include \"hardware/pwm.h\"\n#include \"hardware/gpio.h\"\n\n// Definindo Linhas e Colunas do teclado matricial\n#define ROWS 4\n#define COL 4\n\n// Mapas de pinos para o teclado matricial\nconst uint ROW_PIN[ROWS] = {8, 7, 6, 5};\nconst uint COL_PIN[COL] = {4, 3, 2, 28};\n\n// Definições da Matriz de LEDs 5x5\n#define NUM_LEDS 25\n#define LED_PIN 22 // Pino de saída para WS2812\n#define ANIMATION_FPS 10 // Quadros por segundo\n\n// Mapas de teclas do teclado matricial\nconst char keys[ROWS][COL] = {\n    {'1', '2', '3', 'A'},\n    {'4', '5', '6', 'B'},\n    {'7', '8', '9', 'C'},\n    {'*', '0', '#', 'D'}\n};\n\n// Função para ler o teclado matricial 4x4\nchar read_keypad() {\n    for (int r = 0; r < ROWS; r++) {\n        gpio_put(ROW_PIN[r], true); // Ativação da linha\n        sleep_us(50); \n\n        for (int c = 0; c < COL; c++) {\n            if (gpio_get(COL_PIN[c])) { // Verificação de sinal na coluna\n                gpio_put(ROW_PIN[r], false); // Desativa a linha\n                return keys[r][c]; // Retorna a tecla pressionada\n            }\n        }\n        gpio_put(ROW_PIN[r], false); // Desativa a linha\n    }\n\n    return 0; \n}\n\nuint32_t led_colors[NUM_LEDS]; // Array para armazenar cores dos LEDs\n\n// Funções auxiliares para WS2812\nvoid clean_leds() {\n    for (int i = 0; i < NUM_LEDS; i++) {\n        led_colors[i] = 0x000000; // Apaga todos os LEDs\n    }\n    ws2812_put_pixel(pio0, 0, led_colors);\n}\n\n// Função para acender um único LED na matriz de LEDs 5x5\nvoid turn_on_single_led() {\n    clean_leds();\n    led_colors[0] = 0xFF0000; // Acende o primeiro LED em vermelho\n    ws2812_put_pixel(pio0, 0, led_colors);\n}\n\nvoid config_gpio() {\n    // Configurando as linhas do teclado como saídas\n    for (int i = 0; i < ROWS; i++) {\n        gpio_init(ROW_PIN[i]);\n        gpio_set_dir(ROW_PIN[i], GPIO_OUT);\n    }\n\n    // Configurando as colunas do teclado como entradas com pull-down\n    for (int i = 0; i < COL; i++) {\n        gpio_init(COL_PIN[i]);\n        gpio_set_dir(COL_PIN[i], GPIO_IN);\n        gpio_pull_down(COL_PIN[i]);\n    }\n}\n\nint main() {\n    stdio_init_all();\n    config_gpio();\n\n    // Inicializa o PIO e os LEDs WS2812\n    PIO pio = pio0;\n    int sm = 0;\n    uint offset = pio_add_program(pio, &ws2812_program);\n    ws2812_init(pio, sm, offset, LED_PIN);\n\n    while (true) {\n        char teclado = read_keypad(); // Leitura do teclado matricial 4x4\n\n        if (teclado != 0) { // Se alguma tecla for pressionada\n            printf(\"Tecla pressionada: %c\\n\", teclado);\n\n            if (teclado == 'A') {\n                turn_on_single_led(); // Acende um único LED\n            }\n            else {\n                clean_leds(); // Apaga os LEDs para outras teclas\n            }\n        }\n        sleep_ms(100); // Delay para evitar leituras repetidas\n    }  \n    return 0;   \n}\n"
      },
      "ws2812.c": {
        "content": "#include \"ws2812.pio.h\"\n#include \"hardware/pio.h\"\n#include \"hardware/clocks.h\"\n#include \"config.h\" // Incluir config.h\n\n// Função para inicializar o PIO para controlar os LEDs WS2812\nvoid ws2812_init(PIO pio, uint sm, uint offset, uint pin) {\n    pio_sm_config c = ws2812_program_get_default_config(offset);\n    sm_config_set_sideset_pins(&c, pin);\n    sm_config_set_out_shift(&c, false, true, 24);\n    pio_gpio_init(pio, pin);\n    pio_sm_set_consecutive_pindirs(pio, sm, pin, 1, true);\n    pio_sm_init(pio, sm, offset, &c);\n    pio_sm_set_enabled(pio, sm, true);\n}\n\n// Função para enviar dados para os LEDs WS2812\nvoid ws2812_put_pixel(PIO pio, uint sm, uint32_t *rgb) {\n    // Envia os valores de cor para cada LED na matriz\n    for (int i = 0; i < NUM_LEDS; i++) {\n        pio_sm_put_blocking(pio, sm, rgb[i] << 8u);\n    }\n}\n\n// Função para obter a configuração padrão do programa WS2812\npio_sm_config ws2812_program_get_default_config(uint offset) {\n    pio_sm_config c = pio_get_default_sm_config();\n    sm_config_set_clkdiv(&c, 1.0f);\n    sm_config_set_sideset_pins(&c, 1);\n    sm_config_set_out_shift(&c, false, true, 24);\n    return c;\n}\n\nconst pio_program_t ws2812_program = {\n    .instructions = (uint16_t[]) {\n        0x6221, //  0: out    x, 1\n        0x1123, //  1: jmp    !osre, 3\n        0xa042, //  2: nop          [2]\n        0xa040, //  3: nop\n    },\n    .length = 4,\n    .origin = -1,\n};\n"
      },
      "ws2812.pio.h": {
        "content": "#include \"hardware/pio.h\"\n\n// Funções para inicializar e controlar os LEDs WS2812\nvoid ws2812_init(PIO pio, uint sm, uint offset, uint pin);\nvoid ws2812_put_pixel(PIO pio, uint sm, uint32_t *rgb);\npio_sm_config ws2812_program_get_default_config(uint offset);\n\nextern const pio_program_t ws2812_program;\n"
      },
      "config.h": {
        "content": "#ifndef CONFIG_H\n#define CONFIG_H\n\n// Definições da Matriz de LEDs 5x5\n#define NUM_LEDS 25\n#define LED_PIN 22 // Pino de saída para WS2812\n#define ANIMATION_FPS 10 // Quadros por segundo\n\n#endif // CONFIG_H\n"
      }
    },
    "dependencies": {
      "name": "pico-sdk"
    }
  }
  
